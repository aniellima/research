---
title: "Densidade Populacional"
author: "aniellima"
date: "2022-10-26"
output:
  html_document: 
    df_paged: TRUE
    number_sections: TRUE
---



```{r setup, include=FALSE}
library(pacman)
p_load(formatR, ggplot2, tidyverse, dplyr,  stars, mapview, mapedit,cubeview, sf, units, data.table, dplyr, raster, rasterVis, viridis, ggpubr, rgeos,  exactextractr, knitr, geodata,pinyin)
```



```{r arquivos raster}
gpw2000<-raster("../rawData/pop/China_gpw_v4_population_density_rev11_2000_30s.tif")
gpw2005<-raster("../rawData/pop/China_gpw_v4_population_density_rev11_2005_30s.tif")
gpw2010<-raster("../rawData/pop/China_gpw_v4_population_density_rev11_2010_30s.tif")
gpw2020<-raster("../rawData/pop/China_gpw_v4_population_density_rev11_2020_30s.tif")  
```



```{r arquivos shp}
chinaShp<-st_read("../rawData/shp/ChinaShp/1_Country/country.shp")%>%st_set_crs(4326)
provincesShp<-st_read("../rawData/shp/ChinaShp/2_Province/province.shp")%>%st_set_crs(4326)
citiesShp<-st_read("../rawData/shp/ChinaShp/3_City/city.shp")%>%st_set_crs(4326)
districtsShp<-st_read("../rawData/shp/ChinaShp/4_District/district.shp")%>%st_set_crs(4326)
```



### Traduzindo colunas em pinyin

```{r}
# Vetores para traduzir a unidade de analise de cada base 
# Distritos
dt_pinyin<-py(districtsShp$dt_name, sep = " ", dic=pydic(method = c("toneless"), multi = FALSE,
        only_first_letter = FALSE, dic = c("pinyin2")))

# Cidades
ct_pinyin<-py(citiesShp$ct_name, sep = " ", dic=pydic(method = c("toneless"), multi = FALSE,
        only_first_letter = FALSE, dic = c("pinyin2")))

# Provincias
pr_pinyin<-py(provincesShp$pr_name, sep = " ", dic=pydic(method = c("toneless"), multi = FALSE,
        only_first_letter = FALSE, dic = c("pinyin2")))

```



```{r}

# Unifica vetores com a respectiva base
districtsShp<-cbind(dt_pinyin,districtsShp)
citiesShp<-cbind(ct_pinyin,citiesShp)
provincesShp<-cbind(pr_pinyin,provincesShp)


# realiza o join com a base superior (cidades com provincias)
citiesShp<-left_join(citiesShp, provincesShp %>%as.data.frame() %>%dplyr::select(-geometry), by=c("pr_adcode","pr_name", "cn_adcode","cn_name"))

# ordena variaveis
citiesShp<-citiesShp%>%dplyr::select(ct_adcode, ct_pinyin, ct_name, pr_adcode, pr_pinyin, pr_name, cn_adcode, cn_name)

# realiza o join com a base superior (distritos com cidades)
districtsShp<-left_join(districtsShp,citiesShp %>%as.data.frame() %>%dplyr::select(-geometry), by=c("ct_adcode","ct_name","pr_adcode", "pr_name", "cn_adcode","cn_name"))
# ordena variaveis
districtsShp<-districtsShp%>%dplyr::select(dt_adcode,dt_pinyin,dt_name,ct_adcode, ct_pinyin, ct_name, pr_adcode, pr_pinyin, pr_name, cn_adcode, cn_name)
```




#### Areas projetadas

```{r}
chinaShp%>%ggplot()+geom_sf(fill="#EB984E", color="#000000", size=.1)+theme_bw()
provincesShp%>%ggplot()+geom_sf(fill="#A569BD", color="#000000", size=.1)+theme_bw()
citiesShp%>%ggplot()+geom_sf()+geom_sf(fill="#48C9B0", color="#000000", size=.1)+theme_bw()
districtsShp%>%ggplot()+geom_sf(fill="#F1948A", color="#000000", size=.05)+theme_bw()
```


#### Calcula a as área em Km2

```{r China_Areas}
# transforma um objeto shp em vetor.
areaChina <- chinaShp%>%vect()

# calcula a area do vetor em m2. Divide-se por 1.000.000 para chegar em km2
areaChina$AREA_KM_2 <- expanse(areaChina) / 1000000

# retorna ao sistema de projeão anterior
chinaShp<-areaChina%>%st_as_sf(coords=c("x","y"), 
                                  crs=4326)
```



```{r Provincias_Areas}
# transforma um objeto shp em vetor.
provinciasArea <- provincesShp%>%vect()

# calcula a area do vetor em m2. Divide-se por 1.000.000 para chegar em km2
provinciasArea$AREA_KM_2 <- expanse(provinciasArea) / 1000000

# retorna ao sistema de projeão anterior
provincesShp<-provinciasArea%>%st_as_sf(coords=c("x","y"), 
                                  crs=4326)
```


```{r cidades_Areas}
# transforma um objeto shp em vetor.
cidadesArea <- citiesShp%>%vect()

# calcula a area do vetor em m2. Divide-se por 1.000.000 para chegar em km2
cidadesArea$AREA_KM_2 <- expanse(cidadesArea) / 1000000

# retorna ao sistema de projeão anterior
citiesShp<-cidadesArea%>%st_as_sf(coords=c("x","y"), 
                                  crs=4326)

```



```{r distritos_Areas}
# transforma um objeto shp em vetor.
distritosArea <- districtsShp%>%vect()

# calcula a area do vetor em m2. Divide-se por 1.000.000 para chegar em km2
distritosArea$AREA_KM_2 <- expanse(distritosArea) / 1000000

# retorna ao sistema de projeão anterior
districtsShp<-distritosArea%>%st_as_sf(coords=c("x","y"), 
                                  crs=4326)
```


### Caucula a populacão absoluta por poligono e depois a densida por unidade de analise

```{r raster::area 2000}
# calcula do arquivo em raster já subssessionado 
chinaArea<-raster::area(gpw2000)
```

### Multiplica a area em Km 2 pela populacao em Km 2
```{r}
chinaPop2000<-gpw2000 * chinaArea
```

* Agora somamos para obter a populacao absoluta em 2000

```{r}
sum(chinaPop2000[], na.rm=TRUE)
```


* Com a funcao extratcr calculamos a distribuicao dessa populacao por unidade provincia, prefeitura e distrito e criamos uma variavel para guardar esse valor e outra que divide poulacao por Km2 no poligono. Assim teremos a densidade populacional por cada unidade administrativa: 


```{r }
extracts = exact_extract(chinaPop2000, provincesShp, fun="sum")
#extracts
```


```{r }
provinces2000<-provincesShp
provinces2000$POP = extracts# cria variavel POP com os dados de extracts


provinces2000$POP_Km2 = (provinces2000$POP/provinces2000$AREA_KM_2) # cria variável POP_KM_2 com os dados de pop dividido pela área

provinces2000$Year=2000
```

* Por cidades 

```{r }
extracts = exact_extract(chinaPop2000, citiesShp, fun="sum")
#extracts
```


```{r }
cities2000<-citiesShp
cities2000$POP = extracts # cria variavel POP com os dados de extracts

cities2000$POP_Km2 = (cities2000$POP/cities2000$AREA_KM_2) # cria variável POP_KM_2 com os dados de pop dividido pela área

cities2000$Year=2000
```


* Por distrito

```{r }
extracts = exact_extract(chinaPop2000, districtsShp, fun="sum")
#extracts
```


```{r }
districts2000<-districtsShp
districts2000$POP = extracts # cria variavel POP com os dados de extracts

districts2000$POP_Km2 = (districts2000$POP/districts2000$AREA_KM_2) # cria variável POP_KM_2 com os dados de pop dividido pela área

districts2000$Year=2000
```

### Repete o processo para os anos de 2005, 2010 e 2000 com os bancos de cidades e distritos


### Caucula a populacão absoluta por poligono e depois a densida por unidade de analise

```{r raster::area 2005}
# calcula do arquivo em raster já subssessionado 
chinaArea<-raster::area(gpw2005)
```

### Multiplica a area em Km 2 pela populacao em Km 2
```{r}
chinaPop2005<-gpw2005 * chinaArea
```

* Agora somamos para obter a populacao absoluta em 2005

```{r}
sum(chinaPop2005[], na.rm=TRUE)
```


* Com a funcao extratcr calculamos a distribuicao dessa populacao por unidade provincia, prefeitura e distrito e criamos uma variavel para guardar esse valor e outra que divide poulacao por Km2 no poligono. Assim teremos a densidade populacional por cada unidade administrativa: 


```{r }
extracts = exact_extract(chinaPop2005, provincesShp, fun="sum")
#extracts
```


```{r }
provinces2005<-provincesShp
provinces2005$POP = extracts# cria variavel POP com os dados de extracts


provinces2005$POP_Km2 = (provinces2005$POP/provinces2005$AREA_KM_2) # cria variável POP_KM_2 com os dados de pop dividido pela área

provinces2005$Year=2005


```

* Por cidades 

```{r }
extracts = exact_extract(chinaPop2005, citiesShp, fun="sum")
#extracts
```


```{r }
cities2005<-citiesShp
cities2005$POP = extracts # cria variavel POP com os dados de extracts

cities2005$POP_Km2 = (cities2005$POP/cities2005$AREA_KM_2) # cria variável POP_KM_2 com os dados de pop dividido pela área

cities2005$Year=2005
```


* Por distrito

```{r }
extracts = exact_extract(chinaPop2005, districtsShp, fun="sum")
#extracts
```


```{r }
districts2005<-districtsShp
districts2005$POP = extracts # cria variavel POP com os dados de extracts

districts2005$POP_Km2 = (districts2005$POP/districts2005$AREA_KM_2) # cria variável POP_KM_2 com os dados de pop dividido pela área

districts2005$Year=2005
```





### Caucula a populacão absoluta por poligono e depois a densida por unidade de analise

```{r raster::area 2010}
# calcula do arquivo em raster já subssessionado 
chinaArea<-raster::area(gpw2010)
```

### Multiplica a area em Km 2 pela populacao em Km 2
```{r}
chinaPop2010<-gpw2010 * chinaArea
```

* Agora somamos para obter a populacao absoluta em 2010

```{r}
sum(chinaPop2010[], na.rm=TRUE)
```


* Com a funcao extratcr calculamos a distribuicao dessa populacao por unidade provincia, prefeitura e distrito e criamos uma variavel para guardar esse valor e outra que divide poulacao por Km2 no poligono. Assim teremos a densidade populacional por cada unidade administrativa: 


```{r }
extracts = exact_extract(chinaPop2010, provincesShp, fun="sum")
#extracts
```


```{r }
provinces2010<-provincesShp
provinces2010$POP = extracts # cria variavel POP com os dados de extracts

provinces2010$POP_Km2 = (provinces2010$POP/provinces2010$AREA_KM_2) # cria variável POP_KM_2 com os dados de pop dividido pela área

provinces2010$Year =2010
```

* Por cidades 

```{r }
extracts = exact_extract(chinaPop2010, citiesShp, fun="sum")
#extracts
```


```{r }
cities2010<-citiesShp
cities2010$POP = extracts # cria variavel POP com os dados de extracts


cities2010$POP_Km2 = (cities2010$POP/cities2000$AREA_KM_2) # cria variável POP_KM_2 com os dados de pop dividido pela área

cities2010$Year= 2010
```


* Por distrito

```{r }
extracts = exact_extract(chinaPop2010, districtsShp, fun="sum")
#extracts
```


```{r }
districts2010<-districtsShp
districts2010$POP = extracts # cria variavel POP com os dados de extracts

districts2010$POP_Km2 = (districts2010$POP/districts2010$AREA_KM_2) # cria variável POP_KM_2 com os dados de pop dividido pela área

districts2010$Year = 2010
```

### Repete o processo para os anos de 2020





### Caucula a populacão absoluta por poligono e depois a densida por unidade de analise

```{r raster::area 2020}
# calcula do arquivo em raster já subssessionado 
chinaArea<-raster::area(gpw2020)
```

### Multiplica a area em Km 2 pela populacao em Km 2
```{r}
chinaPop2020<-gpw2020 * chinaArea
```

* Agora somamos para obter a populacao absoluta em 2020

```{r}
sum(chinaPop2020[], na.rm=TRUE)
```


* Com a funcao extratcr calculamos a distribuicao dessa populacao por unidade provincia, prefeitura e distrito e criamos uma variavel para guardar esse valor e outra que divide poulacao por Km2 no poligono. Assim teremos a densidade populacional por cada unidade administrativa: 


```{r }
extracts = exact_extract(chinaPop2020, provincesShp, fun="sum")
#extracts
```


```{r }
provinces2020<-provincesShp
provinces2020$POP = extracts # cria variavel POP com os dados de extracts

provinces2020$POP_Km2 = (provinces2020$POP/provinces2020$AREA_KM_2) # cria variável POP_KM_2 com os dados de pop dividido pela área

provinces2020$Year = 2020
```

* Por cidades 

```{r }
extracts = exact_extract(chinaPop2020, citiesShp, fun="sum")
#extracts
```


```{r }
cities2020<-citiesShp
cities2020$POP_2020 = extracts # cria variavel POP com os dados de extracts

cities2020$POP_Km2 = (cities2020$POP_2020/cities2020$AREA_KM_2) # cria variável POP_KM_2 com os dados de pop dividido pela área


cities2020$Year = 2020
```


* Por distrito

```{r }
extracts = exact_extract(chinaPop2020, districtsShp, fun="sum")
#extracts
```


```{r }
districts2020<-districtsShp
districts2020$POP = extracts # cria variavel POP com os dados de extracts

districts2020$POP_Km2 = (districts2020$POP/districts2020$AREA_KM_2) # cria variável POP_KM_2 com os dados de pop dividido pela área

districts2020$Year = 2020
```


```{r}
districts<-rbind(districts2000, districts2005,districts2010, districts2020)
```


```{r}
  ggplot() +
  geom_sf(data=districts%>%group_by(Year),aes(fill=POP_Km2), color=NA)+
  geom_sf(data = provincesShp, aes(), fill=NA,color="black", size=.1)+
  scale_fill_gradientn(colours = rev(magma(30)), na.value = "transparent", n.breaks = 6)+
  theme_bw()+
  theme(axis.text.x = element_text(size=6))+
  theme(axis.text.y = element_text(size=6))+
  theme(axis.title.x = element_blank())+
  theme(axis.title.y = element_blank())+
  facet_wrap(~Year)+
  ggtitle("Densidade por divisão administrativa distrito")
```




### Porte 

```{r}
districts<-districts%>%mutate(Porte=case_when(POP_Km2<1~0, 
                                              POP_Km2>1&POP_Km2<=25~1,
                                              POP_Km2>25&POP_Km2<=50~25,
                                              POP_Km2>50&POP_Km2<=100~50,
                                              POP_Km2>100&POP_Km2<=200~100,
                                              POP_Km2>200&POP_Km2<=400~200,
                                              POP_Km2>400&POP_Km2<=600~400,
                                              POP_Km2>600&POP_Km2<=800~600,
                                              POP_Km2>800&POP_Km2<=1000~800,
                                              POP_Km2>1000~1000))
```


```{r}
  ggplot() +
  geom_sf(data=districts%>%group_by(Year),aes(fill=Porte), color=NA)+
  geom_sf(data = provincesShp, aes(), fill=NA,color="black", size=.1)+
  scale_fill_gradientn(colours = rev(magma(30)), na.value = "transparent", n.breaks = 6)+
  theme_bw()+
  theme(axis.text.x = element_text(size=6))+
  theme(axis.text.y = element_text(size=6))+
  theme(axis.title.x = element_blank())+
  theme(axis.title.y = element_blank())+
  facet_wrap(~Year)+
  ggtitle("Densidade por distrito(2000-2020")
```


```{r}
  ggplot() +
  geom_sf(data=districts%>%filter(Year==2000|Year==2005)%>%group_by(Year),aes(fill=Porte), color=NA)+
  geom_sf(data = provincesShp, aes(), fill=NA,color="black", size=.1)+
  scale_fill_gradientn(colours = rev(magma(30)), na.value = "transparent", n.breaks = 6)+
  theme_bw()+
  theme(axis.text.x = element_text(size=6))+
  theme(axis.text.y = element_text(size=6))+
  theme(axis.title.x = element_blank())+
  theme(axis.title.y = element_blank())+
  facet_wrap(~Year)+
  ggtitle("Densidade por distrito(2000-2005")
```



```{r}
  ggplot() +
  geom_sf(data=districts%>%filter(Year==2000|Year==2020)%>%group_by(Year),aes(fill=Porte), color=NA)+
  geom_sf(data = provincesShp, aes(), fill=NA,color="black", size=.1)+
  scale_fill_gradientn(colours = rev(magma(30)), na.value = "transparent", n.breaks = 6)+
  theme_bw()+
  theme(axis.text.x = element_text(size=6))+
  theme(axis.text.y = element_text(size=6))+
  theme(axis.title.x = element_blank())+
  theme(axis.title.y = element_blank())+
  facet_wrap(~Year)+
  ggtitle("Densidade por distrito(2000-2020")
```




```{r}
  ggplot() +
  geom_sf(data=districts%>%filter(pr_adcode==650000)%>%group_by(Year),aes(fill=Porte), color=NA)+
  geom_sf(data = provincesShp%>%filter(pr_adcode==650000), aes(), fill=NA,color="black", size=.1)+
  scale_fill_gradientn(colours = rev(magma(30)), na.value = "transparent", n.breaks = 6)+
  theme_bw()+
  theme(axis.text.x = element_text(size=6))+
  theme(axis.text.y = element_text(size=6))+
  theme(axis.title.x = element_blank())+
  theme(axis.title.y = element_blank())+
  facet_wrap(~Year)+
  ggtitle("Densidade por distrito(2000-2020)")
```


### Tian Shan Region

```{r}
tianShan_00<-districts%>%filter(pr_adcode==650000&Year==2000)%>%
 filter(ct_adcode==650100|ct_adcode==650200|ct_adcode==650400|ct_adcode==652300|ct_adcode==652700|ct_adcode==654000|ct_adcode==654200|ct_adcode==652300|ct_adcode==652800|ct_adcode==659004|ct_adcode==659001|ct_adcode==659010|ct_adcode==653007|ct_adcode==659007|ct_adcode==659008)%>%
  filter(dt_adcode!=652801&dt_adcode!=652822&dt_adcode!=652823&dt_adcode!=652824&dt_adcode!=652825)



tianShan_05<-districts%>%filter(pr_adcode==650000&Year==2005)%>%
 filter(ct_adcode==650100|ct_adcode==650200|ct_adcode==650400|ct_adcode==652300|ct_adcode==652700|ct_adcode==654000|ct_adcode==654200|ct_adcode==652300|ct_adcode==652800|ct_adcode==659004|ct_adcode==659001|ct_adcode==659010|ct_adcode==653007|ct_adcode==659007|ct_adcode==659008)%>%
  filter(dt_adcode!=652801&dt_adcode!=652822&dt_adcode!=652823&dt_adcode!=652824&dt_adcode!=652825)


tianShan_10<-districts%>%filter(pr_adcode==650000&Year==2010)%>%
 filter(ct_adcode==650100|ct_adcode==650200|ct_adcode==650400|ct_adcode==652300|ct_adcode==652700|ct_adcode==654000|ct_adcode==654200|ct_adcode==652300|ct_adcode==652800|ct_adcode==659004|ct_adcode==659001|ct_adcode==659010|ct_adcode==653007|ct_adcode==659007|ct_adcode==659008)%>%
  filter(dt_adcode!=652801&dt_adcode!=652822&dt_adcode!=652823&dt_adcode!=652824&dt_adcode!=652825)



tianShan_20<-districts%>%filter(pr_adcode==650000&Year==2020)%>%
  filter(ct_adcode==650100|ct_adcode==650200|ct_adcode==650400|ct_adcode==652300|ct_adcode==652700|ct_adcode==654000|ct_adcode==654200|ct_adcode==652300|ct_adcode==652800|ct_adcode==659004|ct_adcode==659001|ct_adcode==659010|ct_adcode==653007|ct_adcode==659007|ct_adcode==659008)%>%
  filter(dt_adcode!=652801&dt_adcode!=652822&dt_adcode!=652823&dt_adcode!=652824&dt_adcode!=652825)



#Creating XY coordinations for the shp and join it with the the shp file
centroid <- gCentroid(as(districts, "Spatial"), byid = TRUE)
districts<-cbind(districts, centroid)
tianShanReg<-rbind(tianShan_00,tianShan_05,tianShan_10,tianShan_20)
```









```{r}
  ggplot() +
  geom_sf(data=tianShanReg%>%group_by(Year),aes(fill=Porte), color="black", size=0.05)+
  #geom_sf(data = provincesShp%>%filter(pr_adcode==650000), aes(), fill=NA,color="black", size=.1)+
  scale_fill_gradientn(colours = rev(magma(30)), na.value = "transparent", n.breaks = 6)+
  theme_bw()+
  theme(axis.text.x = element_text(size=6))+
  theme(axis.text.y = element_text(size=6))+
  theme(axis.title.x = element_blank())+
  theme(axis.title.y = element_blank())+
  facet_wrap(~Year)+
  ggtitle("Densidade populacional - Região de Interesse(2000-2020)")
```

